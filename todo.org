* Bugs
** printf("%llu", x) prints garbage. sc_print_uint64_dec() seems ok.
   printf, logf work fine in user mode code. Both don't work in supervisor mode
   code, like handle_syscall.
   Hypothesis: supervisor mode stacks are corrupted by the assembly in context_switch.S
   Supervisor mode stack doesn't sense in printf and vprintf. sp is not even aligned.
* Features:
** Some collections (linked / array list, heap, sorted map, hash)
** Timers
*** err_t sys_sleep_until (time_t time_due)
*** err_t sys_get_time (time_t &now)
** Use a pattern for syscall returns: no such syscall, complete with value, blocked.
** fork
** Reclaim resources used by stopped threads. thread_t and stack for now.

* Nice features:
** Track how much time a thread has consumed since it was scheduled and only
   schedule what's left of its assigned quantum.
** Fancier scheduling algorithm. Fixed priority round robin is what's currently
   in there, and that can totally starve low priority threads.
** Thread stats: number of system calls, cpu time used
** Interrupt stats: number of interrupts, cpu time used
** Memory protection
*** Stack overflow detection
*** User-mode lockdown
** Replace static allocation in little tables all over the place with real data
   structures.

   Including:
*** Threads
*** Stacks
*** Thread ready lists

** file interface with v_table for different drivers.
** IPC
** Network I/O
** Disk I/O
** File system

* Nice:
** Support registering callbacks when each timer fires. Enables looser coupling.
** Set user thread return values with a function in syscalls, fetch all arguments with functions too.
** Rename activate() -> activate_thread().
** Rename interrupt -> exception where appropriate, including interrupt_table -> exception_table
** Use macro constants to refer to processor modes
** Tests
** Generate .h file with #define THREAD_OFFSET_* calculated with offsetof
** Assert register contents in busy_loop_thread()

* Won't do
** Modify Makefile to enable precise rebuild on changing TRACE_* variables
*** Implementation idea
**** Store TRACE_* variables in _env_TRACE_* files, modifying the files when
     the environment variables change
**** Add dependencies from C files to _env_TRACE_* for the TRACE_* variables
     they depend on
**** For all TRACE_* parameters != 0, add -DTRACE_*=value parameters to the CFLAGS
*** Snippets
**** Output dependencies from C files to an _env_TRACE_PARAM file, e.g.
     "interrupt.c:env_TRACE_INTERRUPTS"

     egrep '^#if TRACE_' *.c | sort -u | sed -r \
     -e 's/([^:]+):.*(TRACE_\w+)/\1:_env_\2/'
**** Output unique TRACE_ macros
     egrep '^#if TRACE_' *.c | egrep ' TRACE_[a-zA-Z0-9_]+' -o | cut -b2- | sort -u


* Notes:
** User mode read from / write to console in a preemptible way.
*** User mode syscall
*** Syscall handler needs to block?
**** No:
***** Set return data in thread
***** Leave thread state as ready
***** Return to scheduler, or ideally ask to re-schedule the caller
**** Yes:
***** Initialise transfer in hardware
***** Record transfer details including blocked thread_id
***** Set thread state to blocked including what blocked them
      (if only for debugging)
***** Return from syscall with thread blocked value
***** Later an interrupt is raised, the interrupt handler:
****** Reads transfer details
****** Copies data from hardware to user mode buffer
****** Sets syscall return value
****** Set thread state to ready
*** User mode thread is scheduled, returns from syscall with its data.
