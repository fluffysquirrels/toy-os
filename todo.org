* Bugs

* Features:
** User mode can wait for timers.
** Use a pattern for syscall returns: no such syscall, complete with value, blocked.
** fork
** Reclaim resources used by stopped threads. thread_t and stack for now.

* Nice features:
** busy_loop and console_reader have a pathological condition where key presses
   show up slowly. It seems to happen when I type quickly.
   I speculate there is more than one byte in the UART FIFO, read is returning with
   the rx interrupt disabled, and busy_loop is then scheduled

   Possible fixes:
*** console_reader could be re-scheduled after its I/O completes (DONE)
*** Fairer scheduling might help prevent console_reader being starved as much
** Ready list for threads. Hide threads, num_threads variables at the same time.
** Thread priority
** Thread stats: number of system calls, cpu time used
** Interrupt stats: number of interrupts, cpu time used
** Memory protection
*** Stack overflow detection
*** User-mode lockdown
** Dynamic allocation
** IPC
** Network I/O
** Disk I/O
** File system

* Nice:
** Set user thread return values with a function in syscalls
** Rename interrupt -> exception where appropriate, including interrupt_table -> exception_table
** Logging boilerplate reduction
*** printf style message formatting
*** include file location (function name, file name, line number) in message using a macro
*** include failed assert condition in message using a macro
** Extract UNUSED and memset to a util file
** Use macro constants to refer to processor modes
** Tests
** Generate .h file with #define THREAD_OFFSET_* calculated with offsetof
** Assert register contents in the busy loop of second()

* Won't do
** Modify Makefile to enable precise rebuild on changing TRACE_* variables
*** Implementation idea
**** Store TRACE_* variables in _env_TRACE_* files, modifying the files when
     the environment variables change
**** Add dependencies from C files to _env_TRACE_* for the TRACE_* variables
     they depend on
**** For all TRACE_* parameters != 0, add -DTRACE_*=value parameters to the CFLAGS
*** Snippets
**** Output dependencies from C files to an _env_TRACE_PARAM file, e.g.
     "interrupt.c:env_TRACE_INTERRUPTS"

     egrep '^#if TRACE_' *.c | sort -u | sed -r \
     -e 's/([^:]+):.*(TRACE_\w+)/\1:_env_\2/'
**** Output unique TRACE_ macros
     egrep '^#if TRACE_' *.c | egrep ' TRACE_[a-zA-Z0-9_]+' -o | cut -b2- | sort -u


* Notes:
** User mode read from / write to console in a preemptible way.
*** User mode syscall
*** Syscall handler needs to block?
**** No:
***** Set return data in thread
***** Leave thread state as ready
***** Return to scheduler, or ideally ask to re-schedule the caller
**** Yes:
***** Initialise transfer in hardware
***** Record transfer details including blocked thread_id
***** Set thread state to blocked including what blocked them
      (if only for debugging)
***** Return from syscall with thread blocked value
***** Later an interrupt is raised, the interrupt handler:
****** Reads transfer details
****** Copies data from hardware to user mode buffer
****** Sets syscall return value
****** Set thread state to ready
*** User mode thread is scheduled, returns from syscall with its data.
