* Bugs
** printf("%llu", x) prints garbage. sc_print_uint64_dec() seems ok.
** Pause in sleep_thread(). systemnow seems to travel back in time when SP804 TIMER1
   is reset to 1000000 on the RTC interrupt. A quick hack in timer.c to return the
   latest time seen doesn't work.
* Features:
** Some collections (linked / array list, heap, sorted map, hash)
** Timers
*** sys_sleep (WIP)
*** err_t sys_sleep_until (time_t time_due)
*** err_t sys_get_time (time_t &now)
** Use a pattern for syscall returns: no such syscall, complete with value, blocked.
** fork
** Reclaim resources used by stopped threads. thread_t and stack for now.

* Nice features:
** busy_loop and console_reader have a pathological condition where key presses
   show up slowly. It seems to happen when I type quickly.
   I speculate there is more than one byte in the UART FIFO, read is returning with
   the rx interrupt disabled, and busy_loop is then scheduled

   Possible fixes:
*** console_reader could be re-scheduled after its I/O completes (DONE)
*** Prioritise the console reader thread (DONE)
*** Fairer scheduling might help prevent console_reader being starved as much
** Thread stats: number of system calls, cpu time used
** Interrupt stats: number of interrupts, cpu time used
** Memory protection
*** Stack overflow detection
*** User-mode lockdown
** Dynamic allocation
** IPC
** Network I/O
** Disk I/O
** File system

* Nice:
** Support registering callbacks when each timer_sp804 fires.
** Set user thread return values with a function in syscalls, fetch all arguments with functions too.
** Rename activate() -> activate_thread().
** Rename interrupt -> exception where appropriate, including interrupt_table -> exception_table
** Use macro constants to refer to processor modes
** Tests
** Generate .h file with #define THREAD_OFFSET_* calculated with offsetof
** Assert register contents in busy_loop_thread()

* Won't do
** Modify Makefile to enable precise rebuild on changing TRACE_* variables
*** Implementation idea
**** Store TRACE_* variables in _env_TRACE_* files, modifying the files when
     the environment variables change
**** Add dependencies from C files to _env_TRACE_* for the TRACE_* variables
     they depend on
**** For all TRACE_* parameters != 0, add -DTRACE_*=value parameters to the CFLAGS
*** Snippets
**** Output dependencies from C files to an _env_TRACE_PARAM file, e.g.
     "interrupt.c:env_TRACE_INTERRUPTS"

     egrep '^#if TRACE_' *.c | sort -u | sed -r \
     -e 's/([^:]+):.*(TRACE_\w+)/\1:_env_\2/'
**** Output unique TRACE_ macros
     egrep '^#if TRACE_' *.c | egrep ' TRACE_[a-zA-Z0-9_]+' -o | cut -b2- | sort -u


* Notes:
** User mode read from / write to console in a preemptible way.
*** User mode syscall
*** Syscall handler needs to block?
**** No:
***** Set return data in thread
***** Leave thread state as ready
***** Return to scheduler, or ideally ask to re-schedule the caller
**** Yes:
***** Initialise transfer in hardware
***** Record transfer details including blocked thread_id
***** Set thread state to blocked including what blocked them
      (if only for debugging)
***** Return from syscall with thread blocked value
***** Later an interrupt is raised, the interrupt handler:
****** Reads transfer details
****** Copies data from hardware to user mode buffer
****** Sets syscall return value
****** Set thread state to ready
*** User mode thread is scheduled, returns from syscall with its data.
