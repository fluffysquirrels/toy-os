<!DOCTYPE html>
<!-- saved from url=(0051)http://man.openbsd.org/OpenBSD-current/man3/queue.3 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" href="./OpenBSD man page for queue_files/mandoc.css" type="text/css" media="all">
  <title>OpenBSD manual pages</title>
</head>
<body>
<p><a href="https://www.openbsd.org/"><img height="30" width="141" src="./OpenBSD man page for queue_files/openbsd.gif" alt="[OpenBSD]"></a></p>
<form action="http://man.openbsd.org/" method="get">
  <fieldset>
    <legend>Manual Page Search Parameters</legend>
    <input type="text" name="query" value="queue" size="40">
    <button type="submit" name="apropos" value="0">man</button>
    <button type="submit" name="apropos" value="1">apropos</button>
    <br>
    <select name="sec">
      <option value="0">All Sections</option>
      <option value="1">1 - General Commands</option>
      <option value="2">2 - System Calls</option>
      <option value="3" selected="selected">3 - Library Functions</option>
      <option value="3p">3p - Perl Library</option>
      <option value="4">4 - Device Drivers</option>
      <option value="5">5 - File Formats</option>
      <option value="6">6 - Games</option>
      <option value="7">7 - Miscellaneous Information</option>
      <option value="8">8 - System Manager's Manual</option>
      <option value="9">9 - Kernel Developer's Manual</option>
    </select>
    <select name="arch">
      <option value="default" selected="selected">All Architectures</option>
      <option value="amd64">amd64</option>
      <option value="alpha">alpha</option>
      <option value="armv7">armv7</option>
      <option value="arm64">arm64</option>
      <option value="hppa">hppa</option>
      <option value="i386">i386</option>
      <option value="landisk">landisk</option>
      <option value="loongson">loongson</option>
      <option value="luna88k">luna88k</option>
      <option value="macppc">macppc</option>
      <option value="mips64">mips64</option>
      <option value="octeon">octeon</option>
      <option value="sgi">sgi</option>
      <option value="socppc">socppc</option>
      <option value="sparc64">sparc64</option>
      <option value="amiga">amiga</option>
      <option value="arc">arc</option>
      <option value="armish">armish</option>
      <option value="arm32">arm32</option>
      <option value="atari">atari</option>
      <option value="aviion">aviion</option>
      <option value="beagle">beagle</option>
      <option value="cats">cats</option>
      <option value="hppa64">hppa64</option>
      <option value="hp300">hp300</option>
      <option value="ia64">ia64</option>
      <option value="mac68k">mac68k</option>
      <option value="mvme68k">mvme68k</option>
      <option value="mvme88k">mvme88k</option>
      <option value="mvmeppc">mvmeppc</option>
      <option value="palm">palm</option>
      <option value="pc532">pc532</option>
      <option value="pegasos">pegasos</option>
      <option value="pmax">pmax</option>
      <option value="powerpc">powerpc</option>
      <option value="solbourne">solbourne</option>
      <option value="sparc">sparc</option>
      <option value="sun3">sun3</option>
      <option value="vax">vax</option>
      <option value="wgrisc">wgrisc</option>
      <option value="x68k">x68k</option>
      <option value="zaurus">zaurus</option>
    </select>
    <select name="manpath">
      <option selected="selected" value="OpenBSD-current">OpenBSD-current</option>
      <option value="OpenBSD-6.0">OpenBSD-6.0</option>
      <option value="OpenBSD-5.9">OpenBSD-5.9</option>
      <option value="POSIX-2013">POSIX-2013</option>
      <option value="4.4BSD-Lite2">4.4BSD-Lite2</option>
      <option value="UNIX-7">UNIX-7</option>
      <option value="FreeBSD-10.3">FreeBSD-10.3</option>
      <option value="DragonFly-4.6.0">DragonFly-4.6.0</option>
      <option value="NetBSD-7.0.1">NetBSD-7.0.1</option>
      <option value="Linux-4.05">Linux-4.05</option>
      <option value="OpenBSD-5.8">OpenBSD-5.8</option>
      <option value="OpenBSD-5.7">OpenBSD-5.7</option>
      <option value="OpenBSD-5.6">OpenBSD-5.6</option>
      <option value="OpenBSD-5.5">OpenBSD-5.5</option>
      <option value="OpenBSD-5.4">OpenBSD-5.4</option>
      <option value="OpenBSD-5.3">OpenBSD-5.3</option>
      <option value="OpenBSD-5.2">OpenBSD-5.2</option>
      <option value="OpenBSD-5.1">OpenBSD-5.1</option>
      <option value="OpenBSD-5.0">OpenBSD-5.0</option>
      <option value="OpenBSD-4.9">OpenBSD-4.9</option>
      <option value="OpenBSD-4.8">OpenBSD-4.8</option>
      <option value="OpenBSD-4.7">OpenBSD-4.7</option>
      <option value="OpenBSD-4.6">OpenBSD-4.6</option>
      <option value="OpenBSD-4.5">OpenBSD-4.5</option>
      <option value="OpenBSD-4.4">OpenBSD-4.4</option>
      <option value="OpenBSD-4.3">OpenBSD-4.3</option>
      <option value="OpenBSD-4.2">OpenBSD-4.2</option>
      <option value="OpenBSD-4.1">OpenBSD-4.1</option>
      <option value="OpenBSD-4.0">OpenBSD-4.0</option>
      <option value="OpenBSD-3.9">OpenBSD-3.9</option>
      <option value="OpenBSD-3.8">OpenBSD-3.8</option>
      <option value="OpenBSD-3.7">OpenBSD-3.7</option>
      <option value="OpenBSD-3.6">OpenBSD-3.6</option>
      <option value="OpenBSD-3.5">OpenBSD-3.5</option>
      <option value="OpenBSD-3.4">OpenBSD-3.4</option>
      <option value="OpenBSD-3.3">OpenBSD-3.3</option>
      <option value="OpenBSD-3.2">OpenBSD-3.2</option>
      <option value="OpenBSD-3.1">OpenBSD-3.1</option>
      <option value="OpenBSD-3.0">OpenBSD-3.0</option>
      <option value="OpenBSD-2.9">OpenBSD-2.9</option>
      <option value="OpenBSD-2.8">OpenBSD-2.8</option>
      <option value="OpenBSD-2.7">OpenBSD-2.7</option>
      <option value="OpenBSD-2.6">OpenBSD-2.6</option>
      <option value="OpenBSD-2.5">OpenBSD-2.5</option>
      <option value="OpenBSD-2.4">OpenBSD-2.4</option>
      <option value="OpenBSD-2.3">OpenBSD-2.3</option>
      <option value="OpenBSD-2.2">OpenBSD-2.2</option>
      <option value="FreeBSD-10.2">FreeBSD-10.2</option>
      <option value="FreeBSD-10.0">FreeBSD-10.0</option>
      <option value="DragonFly-4.4.2">DragonFly-4.4.2</option>
      <option value="DragonFly-3.8.2">DragonFly-3.8.2</option>
      <option value="NetBSD-7.0">NetBSD-7.0</option>
      <option value="NetBSD-6.1.5">NetBSD-6.1.5</option>
    </select>
  </fieldset>
</form>
<table class="head">
  <tbody>
    <tr>
      <td class="head-ltitle">SLIST_INIT(3)</td>
      <td class="head-vol">Library Functions Manual</td>
      <td class="head-rtitle">SLIST_INIT(3)</td>
    </tr>
  </tbody>
</table>
<div class="manual-text">
<h1 class="Sh" id="NAME">NAME</h1>
<b class="Nm">SLIST_ENTRY</b>, <b class="Nm">SLIST_HEAD</b>,
  <b class="Nm">SLIST_HEAD_INITIALIZER</b>, <b class="Nm">SLIST_FIRST</b>,
  <b class="Nm">SLIST_NEXT</b>, <b class="Nm">SLIST_EMPTY</b>,
  <b class="Nm">SLIST_FOREACH</b>, <b class="Nm">SLIST_FOREACH_SAFE</b>,
  <b class="Nm">SLIST_INIT</b>, <b class="Nm">SLIST_INSERT_AFTER</b>,
  <b class="Nm">SLIST_INSERT_HEAD</b>, <b class="Nm">SLIST_REMOVE_AFTER</b>,
  <b class="Nm">SLIST_REMOVE_HEAD</b>, <b class="Nm">SLIST_REMOVE</b>,
  <b class="Nm">LIST_ENTRY</b>, <b class="Nm">LIST_HEAD</b>,
  <b class="Nm">LIST_HEAD_INITIALIZER</b>, <b class="Nm">LIST_FIRST</b>,
  <b class="Nm">LIST_NEXT</b>, <b class="Nm">LIST_EMPTY</b>,
  <b class="Nm">LIST_FOREACH</b>, <b class="Nm">LIST_FOREACH_SAFE</b>,
  <b class="Nm">LIST_INIT</b>, <b class="Nm">LIST_INSERT_AFTER</b>,
  <b class="Nm">LIST_INSERT_BEFORE</b>, <b class="Nm">LIST_INSERT_HEAD</b>,
  <b class="Nm">LIST_REMOVE</b>, <b class="Nm">LIST_REPLACE</b>,
  <b class="Nm">SIMPLEQ_ENTRY</b>, <b class="Nm">SIMPLEQ_HEAD</b>,
  <b class="Nm">SIMPLEQ_HEAD_INITIALIZER</b>, <b class="Nm">SIMPLEQ_FIRST</b>,
  <b class="Nm">SIMPLEQ_NEXT</b>, <b class="Nm">SIMPLEQ_EMPTY</b>,
  <b class="Nm">SIMPLEQ_FOREACH</b>, <b class="Nm">SIMPLEQ_FOREACH_SAFE</b>,
  <b class="Nm">SIMPLEQ_INIT</b>, <b class="Nm">SIMPLEQ_INSERT_AFTER</b>,
  <b class="Nm">SIMPLEQ_INSERT_HEAD</b>, <b class="Nm">SIMPLEQ_INSERT_TAIL</b>,
  <b class="Nm">SIMPLEQ_REMOVE_AFTER</b>, <b class="Nm">SIMPLEQ_REMOVE_HEAD</b>,
  <b class="Nm">SIMPLEQ_CONCAT</b>, <b class="Nm">TAILQ_ENTRY</b>,
  <b class="Nm">TAILQ_HEAD</b>, <b class="Nm">TAILQ_HEAD_INITIALIZER</b>,
  <b class="Nm">TAILQ_FIRST</b>, <b class="Nm">TAILQ_NEXT</b>,
  <b class="Nm">TAILQ_LAST</b>, <b class="Nm">TAILQ_PREV</b>,
  <b class="Nm">TAILQ_EMPTY</b>, <b class="Nm">TAILQ_FOREACH</b>,
  <b class="Nm">TAILQ_FOREACH_SAFE</b>, <b class="Nm">TAILQ_FOREACH_REVERSE</b>,
  <b class="Nm">TAILQ_FOREACH_REVERSE_SAFE</b>, <b class="Nm">TAILQ_INIT</b>,
  <b class="Nm">TAILQ_INSERT_AFTER</b>, <b class="Nm">TAILQ_INSERT_BEFORE</b>,
  <b class="Nm">TAILQ_INSERT_HEAD</b>, <b class="Nm">TAILQ_INSERT_TAIL</b>,
  <b class="Nm">TAILQ_REMOVE</b>, <b class="Nm">TAILQ_REPLACE</b>,
  <b class="Nm">TAILQ_CONCAT</b> â€” <span class="Nd">implementations of
  singly-linked lists, doubly-linked lists, simple queues, and tail
  queues</span>
<h1 class="Sh" id="SYNOPSIS">SYNOPSIS</h1>
<b class="In">#include &lt;<a class="In">sys/queue.h</a>&gt;</b>
<div class="Pp"></div>
<br>
<b class="Fn">SLIST_ENTRY</b>(<i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">SLIST_HEAD</b>(<i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">SLIST_HEAD_INITIALIZER</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">SLIST_FIRST</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">SLIST_NEXT</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">int</i>
<br>
<b class="Fn">SLIST_EMPTY</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>);
<div class="Pp"></div>
<b class="Fn">SLIST_FOREACH</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">SLIST_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">SLIST_FOREACH_SAFE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">SLIST_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TEMP_VARNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_INIT</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_INSERT_AFTER</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_INSERT_HEAD</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_REMOVE_AFTER</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_REMOVE_HEAD</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SLIST_REMOVE</b>(<i class="Fa" style="white-space: nowrap;">SLIST_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">TYPE</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<br>
<b class="Fn">LIST_ENTRY</b>(<i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">LIST_HEAD</b>(<i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">LIST_HEAD_INITIALIZER</b>(<i class="Fa" style="white-space: nowrap;">LIST_HEAD
  head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">LIST_FIRST</b>(<i class="Fa" style="white-space: nowrap;">LIST_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">LIST_NEXT</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">int</i>
<br>
<b class="Fn">LIST_EMPTY</b>(<i class="Fa" style="white-space: nowrap;">LIST_HEAD
  *head</i>);
<div class="Pp"></div>
<b class="Fn">LIST_FOREACH</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">LIST_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">LIST_FOREACH_SAFE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">LIST_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TEMP_VARNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_INIT</b>(<i class="Fa" style="white-space: nowrap;">LIST_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_INSERT_AFTER</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_INSERT_BEFORE</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_INSERT_HEAD</b>(<i class="Fa" style="white-space: nowrap;">LIST_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_REMOVE</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">LIST_REPLACE</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *elm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *elm2</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<br>
<b class="Fn">SIMPLEQ_ENTRY</b>(<i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">SIMPLEQ_HEAD</b>(<i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">SIMPLEQ_HEAD_INITIALIZER</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">SIMPLEQ_FIRST</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">SIMPLEQ_NEXT</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">int</i>
<br>
<b class="Fn">SIMPLEQ_EMPTY</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>);
<div class="Pp"></div>
<b class="Fn">SIMPLEQ_FOREACH</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">SIMPLEQ_FOREACH_SAFE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TEMP_VARNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_INIT</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_INSERT_AFTER</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_INSERT_HEAD</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_INSERT_TAIL</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_REMOVE_AFTER</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">SIMPLEQ_REMOVE_HEAD</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">SIMPLEQ_CONCAT</b>(<i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head1</i>, <i class="Fa" style="white-space: nowrap;">SIMPLEQ_HEAD
  *head2</i>);
<div class="Pp"></div>
<br>
<b class="Fn">TAILQ_ENTRY</b>(<i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_HEAD</b>(<i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TYPE</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_HEAD_INITIALIZER</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">TAILQ_FIRST</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">TAILQ_NEXT</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">TAILQ_LAST</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">HEADNAME</i>);
<div class="Pp"></div>
<i class="Ft">struct TYPE *</i>
<br>
<b class="Fn">TAILQ_PREV</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">int</i>
<br>
<b class="Fn">TAILQ_EMPTY</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_FOREACH</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TAILQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_FOREACH_SAFE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TAILQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TEMP_VARNAME</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_FOREACH_REVERSE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TAILQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_FOREACH_REVERSE_SAFE</b>(<i class="Fa" style="white-space: nowrap;">VARNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TAILQ_HEAD *head</i>,
  <i class="Fa" style="white-space: nowrap;">HEADNAME</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>,
  <i class="Fa" style="white-space: nowrap;">TEMP_VARNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_INIT</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_INSERT_AFTER</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_INSERT_BEFORE</b>(<i class="Fa" style="white-space: nowrap;">struct
  TYPE *listelm</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE
  *elm</i>, <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_INSERT_HEAD</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_INSERT_TAIL</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_REMOVE</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<i class="Ft">void</i>
<br>
<b class="Fn">TAILQ_REPLACE</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head</i>, <i class="Fa" style="white-space: nowrap;">struct TYPE *elm</i>,
  <i class="Fa" style="white-space: nowrap;">struct TYPE *elm2</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<div class="Pp"></div>
<b class="Fn">TAILQ_CONCAT</b>(<i class="Fa" style="white-space: nowrap;">TAILQ_HEAD
  *head1</i>, <i class="Fa" style="white-space: nowrap;">TAILQ_HEAD *head2</i>,
  <i class="Fa" style="white-space: nowrap;">FIELDNAME</i>);
<h1 class="Sh" id="DESCRIPTION">DESCRIPTION</h1>
These macros define and operate on four types of data structures: singly-linked
  lists, simple queues, lists, and tail queues. All four structures support the
  following functionality:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">Insertion of a new entry at
      the head of the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Insertion of a new entry after
      any element in the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Removal of an entry from the
      head of the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Forward traversal through the
      list.</li>
</ol>
<div class="Pp"></div>
Singly-linked lists are the simplest of the four data structures and support
  only the above functionality. Singly-linked lists are ideal for applications
  with large datasets and few or no removals, or for implementing a LIFO queue.
<div class="Pp"></div>
Simple queues add the following functionality:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">Entries can be added at the
      end of a list.</li>
</ol>
<div class="Pp"></div>
However:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">All list insertions must
      specify the head of the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Each head entry requires two
      pointers rather than one.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Code size is about 15% greater
      and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="Pp"></div>
Simple queues are ideal for applications with large datasets and few or no
  removals, or for implementing a FIFO queue.
<div class="Pp"></div>
All doubly linked types of data structures (lists and tail queues) additionally
  allow:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">Insertion of a new entry
      before any element in the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Removal of any entry in the
      list.</li>
</ol>
<div class="Pp"></div>
However:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">Each element requires two
      pointers rather than one.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Code size and execution time
      of operations (except for removal) is about twice that of the
      singly-linked data-structures.</li>
</ol>
<div class="Pp"></div>
Lists are the simplest of the doubly linked data structures and support only the
  above functionality over singly-linked lists.
<div class="Pp"></div>
Tail queues add the following functionality:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">Entries can be added at the
      end of a list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">They may be traversed
      backwards, at a cost.</li>
</ol>
<div class="Pp"></div>
However:
<div class="Pp"></div>
<ol class="Bl-enum" style="margin-left: 6.00ex;">
  <li class="It-enum" style="margin-top: 0.00em;">All list insertions and
      removals must specify the head of the list.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Each head entry requires two
      pointers rather than one.</li>
  <li class="It-enum" style="margin-top: 0.00em;">Code size is about 15% greater
      and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="Pp"></div>
An additional type of data structure, circular queues, violated the C language
  aliasing rules and were miscompiled as a result. All code using them should be
  converted to another structure; tail queues are usually the easiest to convert
  to.
<div class="Pp"></div>
In the macro definitions, <i class="Fa">TYPE</i> is the name tag of a user
  defined structure that must contain a field of type
  <code class="Li">SLIST_ENTRY</code>, <code class="Li">LIST_ENTRY</code>,
  <code class="Li">SIMPLEQ_ENTRY</code>, or <code class="Li">TAILQ_ENTRY</code>,
  named <i class="Fa">FIELDNAME</i>. The argument <i class="Fa">HEADNAME</i> is
  the name tag of a user defined structure that must be declared using the
  macros <b class="Fn">SLIST_HEAD</b>(), <b class="Fn">LIST_HEAD</b>(),
  <b class="Fn">SIMPLEQ_HEAD</b>(), or <b class="Fn">TAILQ_HEAD</b>(). See the
  examples below for further explanation of how these macros are used.
<h1 class="Sh" id="SINGLY-LINKED_LISTS">SINGLY-LINKED LISTS</h1>
A singly-linked list is headed by a structure defined by the
  <b class="Fn">SLIST_HEAD</b>() macro. This structure contains a single pointer
  to the first element on the list. The elements are singly linked for minimum
  space and pointer manipulation overhead at the expense of O(n) removal for
  arbitrary elements. New elements can be added to the list after an existing
  element or at the head of the list. A <i class="Fa">SLIST_HEAD</i> structure
  is declared as follows:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SLIST_HEAD(HEADNAME, TYPE) head;
</pre>
</div>
<div class="Pp"></div>
where <i class="Fa">HEADNAME</i> is the name of the structure to be defined, and
  struct <i class="Fa">TYPE</i> is the type of the elements to be linked into
  the list. A pointer to the head of the list can later be declared as:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">struct HEADNAME *headp;
</pre>
</div>
<div class="Pp"></div>
(The names <code class="Li">head</code> and <code class="Li">headp</code> are
  user selectable.)
<div class="Pp"></div>
The <i class="Fa">HEADNAME</i> facility is often not used, leading to the
  following bizarre code:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SLIST_HEAD(, TYPE) head, *headp;
</pre>
</div>
<div class="Pp"></div>
The <b class="Fn">SLIST_ENTRY</b>() macro declares a structure that connects the
  elements in the list.
<div class="Pp"></div>
The <b class="Fn">SLIST_INIT</b>() macro initializes the list referenced by
  <i class="Fa">head</i>.
<div class="Pp"></div>
The list can also be initialized statically by using the
  <b class="Fn">SLIST_HEAD_INITIALIZER</b>() macro like this:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SLIST_HEAD(HEADNAME, TYPE) head = SLIST_HEAD_INITIALIZER(head);
</pre>
</div>
<div class="Pp"></div>
The <b class="Fn">SLIST_INSERT_HEAD</b>() macro inserts the new element
  <i class="Fa">elm</i> at the head of the list.
<div class="Pp"></div>
The <b class="Fn">SLIST_INSERT_AFTER</b>() macro inserts the new element
  <i class="Fa">elm</i> after the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">SLIST_REMOVE_HEAD</b>() macro removes the first element of the
  list pointed by <i class="Fa">head</i>.
<div class="Pp"></div>
The <b class="Fn">SLIST_REMOVE_AFTER</b>() macro removes the list element
  immediately following <i class="Fa">elm</i>.
<div class="Pp"></div>
The <b class="Fn">SLIST_REMOVE</b>() macro removes the element
  <i class="Fa">elm</i> of the list pointed by <i class="Fa">head</i>.
<div class="Pp"></div>
The <b class="Fn">SLIST_FIRST</b>() and <b class="Fn">SLIST_NEXT</b>() macros
  can be used to traverse the list:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">for (np = SLIST_FIRST(&amp;head); np != NULL; np = SLIST_NEXT(np, FIELDNAME))
</pre>
</div>
<div class="Pp"></div>
Or, for simplicity, one can use the <b class="Fn">SLIST_FOREACH</b>() macro:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SLIST_FOREACH(np, head, FIELDNAME)
</pre>
</div>
<div class="Pp"></div>
The macro <b class="Fn">SLIST_FOREACH_SAFE</b>() traverses the list referenced
  by head in a forward direction, assigning each element in turn to var.
  However, unlike <b class="Fn">SLIST_FOREACH</b>() it is permitted to remove
  var as well as free it from within the loop safely without interfering with
  the traversal.
<div class="Pp"></div>
The <b class="Fn">SLIST_EMPTY</b>() macro should be used to check whether a
  simple list is empty.
<h1 class="Sh" id="SINGLY-LINKED_LIST_EXAMPLE">SINGLY-LINKED LIST EXAMPLE</h1>
<div class="Bd" style="margin-left: 0.00ex;">
<pre class="Li">SLIST_HEAD(listhead, entry) head; 
struct entry { 
	... 
	SLIST_ENTRY(entry) entries;	/* Simple list. */ 
	... 
} *n1, *n2, *np; 
 
SLIST_INIT(&amp;head);			/* Initialize simple list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SLIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SLIST_INSERT_AFTER(n1, n2, entries); 
 
SLIST_FOREACH(np, &amp;head, entries)	/* Forward traversal. */ 
	np-&gt; ... 
 
while (!SLIST_EMPTY(&amp;head)) {	 	/* Delete. */ 
	n1 = SLIST_FIRST(&amp;head); 
	SLIST_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
} 

</pre>
</div>
<h1 class="Sh" id="LISTS">LISTS</h1>
A list is headed by a structure defined by the <b class="Fn">LIST_HEAD</b>()
  macro. This structure contains a single pointer to the first element on the
  list. The elements are doubly linked so that an arbitrary element can be
  removed without traversing the list. New elements can be added to the list
  after an existing element, before an existing element, or at the head of the
  list. A <i class="Fa">LIST_HEAD</i> structure is declared as follows:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">LIST_HEAD(HEADNAME, TYPE) head;
</pre>
</div>
<div class="Pp"></div>
where <i class="Fa">HEADNAME</i> is the name of the structure to be defined, and
  struct <i class="Fa">TYPE</i> is the type of the elements to be linked into
  the list. A pointer to the head of the list can later be declared as:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">struct HEADNAME *headp;
</pre>
</div>
<div class="Pp"></div>
(The names <code class="Li">head</code> and <code class="Li">headp</code> are
  user selectable.)
<div class="Pp"></div>
The <i class="Fa">HEADNAME</i> facility is often not used, leading to the
  following bizarre code:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">LIST_HEAD(, TYPE) head, *headp;
</pre>
</div>
<div class="Pp"></div>
The <b class="Fn">LIST_ENTRY</b>() macro declares a structure that connects the
  elements in the list.
<div class="Pp"></div>
The <b class="Fn">LIST_INIT</b>() macro initializes the list referenced by
  <i class="Fa">head</i>.
<div class="Pp"></div>
The list can also be initialized statically by using the
  <b class="Fn">LIST_HEAD_INITIALIZER</b>() macro like this:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">LIST_HEAD(HEADNAME, TYPE) head = LIST_HEAD_INITIALIZER(head);
</pre>
</div>
<div class="Pp"></div>
The <b class="Fn">LIST_INSERT_HEAD</b>() macro inserts the new element
  <i class="Fa">elm</i> at the head of the list.
<div class="Pp"></div>
The <b class="Fn">LIST_INSERT_AFTER</b>() macro inserts the new element
  <i class="Fa">elm</i> after the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">LIST_INSERT_BEFORE</b>() macro inserts the new element
  <i class="Fa">elm</i> before the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">LIST_REMOVE</b>() macro removes the element
  <i class="Fa">elm</i> from the list.
<div class="Pp"></div>
The <b class="Fn">LIST_REPLACE</b>() macro replaces the list element
  <i class="Fa">elm</i> with the new element <i class="Fa">elm2</i>.
<div class="Pp"></div>
The <b class="Fn">LIST_FIRST</b>() and <b class="Fn">LIST_NEXT</b>() macros can
  be used to traverse the list:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">for (np = LIST_FIRST(&amp;head); np != NULL; np = LIST_NEXT(np, FIELDNAME))
</pre>
</div>
<div class="Pp"></div>
Or, for simplicity, one can use the <b class="Fn">LIST_FOREACH</b>() macro:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">LIST_FOREACH(np, head, FIELDNAME)
</pre>
</div>
<div class="Pp"></div>
The macro <b class="Fn">LIST_FOREACH_SAFE</b>() traverses the list referenced by
  head in a forward direction, assigning each element in turn to var. However,
  unlike <b class="Fn">LIST_FOREACH</b>() it is permitted to remove var as well
  as free it from within the loop safely without interfering with the traversal.
<div class="Pp"></div>
The <b class="Fn">LIST_EMPTY</b>() macro should be used to check whether a list
  is empty.
<h1 class="Sh" id="LIST_EXAMPLE">LIST EXAMPLE</h1>
<div class="Bd" style="margin-left: 0.00ex;">
<pre class="Li">LIST_HEAD(listhead, entry) head; 
struct entry { 
	... 
	LIST_ENTRY(entry) entries;	/* List. */ 
	... 
} *n1, *n2, *np; 
 
LIST_INIT(&amp;head);			/* Initialize list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
LIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
LIST_INSERT_AFTER(n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
LIST_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
LIST_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
 
while (!LIST_EMPTY(&amp;head)) {		/* Delete. */ 
	n1 = LIST_FIRST(&amp;head); 
	LIST_REMOVE(n1, entries); 
	free(n1); 
}
</pre>
</div>
<h1 class="Sh" id="SIMPLE_QUEUES">SIMPLE QUEUES</h1>
A simple queue is headed by a structure defined by the
  <b class="Fn">SIMPLEQ_HEAD</b>() macro. This structure contains a pair of
  pointers, one to the first element in the simple queue and the other to the
  last element in the simple queue. The elements are singly linked. New elements
  can be added to the queue after an existing element, at the head of the queue
  or at the tail of the queue. A <i class="Fa">SIMPLEQ_HEAD</i> structure is
  declared as follows:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SIMPLEQ_HEAD(HEADNAME, TYPE) head;
</pre>
</div>
<div class="Pp"></div>
where <i class="Fa">HEADNAME</i> is the name of the structure to be defined, and
  struct <i class="Fa">TYPE</i> is the type of the elements to be linked into
  the queue. A pointer to the head of the queue can later be declared as:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">struct HEADNAME *headp;
</pre>
</div>
<div class="Pp"></div>
(The names <code class="Li">head</code> and <code class="Li">headp</code> are
  user selectable.)
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_ENTRY</b>() macro declares a structure that connects
  the elements in the queue.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_INIT</b>() macro initializes the queue referenced by
  <i class="Fa">head</i>.
<div class="Pp"></div>
The queue can also be initialized statically by using the
  <b class="Fn">SIMPLEQ_HEAD_INITIALIZER</b>() macro like this:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SIMPLEQ_HEAD(HEADNAME, TYPE) head = SIMPLEQ_HEAD_INITIALIZER(head);
</pre>
</div>
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_INSERT_AFTER</b>() macro inserts the new element
  <i class="Fa">elm</i> after the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_INSERT_HEAD</b>() macro inserts the new element
  <i class="Fa">elm</i> at the head of the queue.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_INSERT_TAIL</b>() macro inserts the new element
  <i class="Fa">elm</i> at the end of the queue.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_REMOVE_AFTER</b>() macro removes the queue element
  immediately following <i class="Fa">elm</i>.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_REMOVE_HEAD</b>() macro removes the first element from
  the queue.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_CONCAT</b>() macro concatenates all the elements of
  the queue referenced by <i class="Fa">head2</i> to the end of the queue
  referenced by <i class="Fa">head1</i>, emptying <i class="Fa">head2</i> in the
  process. This is more efficient than removing and inserting the individual
  elements as it does not actually traverse <i class="Fa">head2</i>.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_FIRST</b>() and <b class="Fn">SIMPLEQ_NEXT</b>()
  macros can be used to traverse the queue. The
  <b class="Fn">SIMPLEQ_FOREACH</b>() is used for queue traversal:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">SIMPLEQ_FOREACH(np, head, FIELDNAME)
</pre>
</div>
<div class="Pp"></div>
The macro <b class="Fn">SIMPLEQ_FOREACH_SAFE</b>() traverses the queue
  referenced by head in a forward direction, assigning each element in turn to
  var. However, unlike <b class="Fn">SIMPLEQ_FOREACH</b>() it is permitted to
  remove var as well as free it from within the loop safely without interfering
  with the traversal.
<div class="Pp"></div>
The <b class="Fn">SIMPLEQ_EMPTY</b>() macro should be used to check whether a
  list is empty.
<h1 class="Sh" id="SIMPLE_QUEUE_EXAMPLE">SIMPLE QUEUE EXAMPLE</h1>
<div class="Bd" style="margin-left: 0.00ex;">
<pre class="Li">SIMPLEQ_HEAD(listhead, entry) head = SIMPLEQ_HEAD_INITIALIZER(head); 
struct entry { 
	... 
	SIMPLEQ_ENTRY(entry) entries;	/* Simple queue. */ 
	... 
} *n1, *n2, *np; 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SIMPLEQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SIMPLEQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
SIMPLEQ_INSERT_TAIL(&amp;head, n2, entries); 
					/* Forward traversal. */ 
SIMPLEQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Delete. */ 
while (!SIMPLEQ_EMPTY(&amp;head)) { 
	n1 = SIMPLEQ_FIRST(&amp;head); 
	SIMPLEQ_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
}
</pre>
</div>
<h1 class="Sh" id="TAIL_QUEUES">TAIL QUEUES</h1>
A tail queue is headed by a structure defined by the
  <b class="Fn">TAILQ_HEAD</b>() macro. This structure contains a pair of
  pointers, one to the first element in the tail queue and the other to the last
  element in the tail queue. The elements are doubly linked so that an arbitrary
  element can be removed without traversing the tail queue. New elements can be
  added to the queue after an existing element, before an existing element, at
  the head of the queue, or at the end of the queue. A
  <i class="Fa">TAILQ_HEAD</i> structure is declared as follows:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">TAILQ_HEAD(HEADNAME, TYPE) head;
</pre>
</div>
<div class="Pp"></div>
where <i class="Fa">HEADNAME</i> is the name of the structure to be defined, and
  struct <i class="Fa">TYPE</i> is the type of the elements to be linked into
  the tail queue. A pointer to the head of the tail queue can later be declared
  as:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">struct HEADNAME *headp;
</pre>
</div>
<div class="Pp"></div>
(The names <code class="Li">head</code> and <code class="Li">headp</code> are
  user selectable.)
<div class="Pp"></div>
The <b class="Fn">TAILQ_ENTRY</b>() macro declares a structure that connects the
  elements in the tail queue.
<div class="Pp"></div>
The <b class="Fn">TAILQ_INIT</b>() macro initializes the tail queue referenced
  by <i class="Fa">head</i>.
<div class="Pp"></div>
The tail queue can also be initialized statically by using the
  <b class="Fn">TAILQ_HEAD_INITIALIZER</b>() macro.
<div class="Pp"></div>
The <b class="Fn">TAILQ_INSERT_HEAD</b>() macro inserts the new element
  <i class="Fa">elm</i> at the head of the tail queue.
<div class="Pp"></div>
The <b class="Fn">TAILQ_INSERT_TAIL</b>() macro inserts the new element
  <i class="Fa">elm</i> at the end of the tail queue.
<div class="Pp"></div>
The <b class="Fn">TAILQ_INSERT_AFTER</b>() macro inserts the new element
  <i class="Fa">elm</i> after the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">TAILQ_INSERT_BEFORE</b>() macro inserts the new element
  <i class="Fa">elm</i> before the element <i class="Fa">listelm</i>.
<div class="Pp"></div>
The <b class="Fn">TAILQ_REMOVE</b>() macro removes the element
  <i class="Fa">elm</i> from the tail queue.
<div class="Pp"></div>
The <b class="Fn">TAILQ_REPLACE</b>() macro replaces the list element
  <i class="Fa">elm</i> with the new element <i class="Fa">elm2</i>.
<div class="Pp"></div>
The <b class="Fn">TAILQ_CONCAT</b>() macro concatenates all the elements of the
  tail queue referenced by <i class="Fa">head2</i> to the end of the tail queue
  referenced by <i class="Fa">head1</i>, emptying <i class="Fa">head2</i> in the
  process. This is more efficient than removing and inserting the individual
  elements as it does not actually traverse <i class="Fa">head2</i>.
<div class="Pp"></div>
<b class="Fn">TAILQ_FOREACH</b>() and <b class="Fn">TAILQ_FOREACH_REVERSE</b>()
  are used for traversing a tail queue. <b class="Fn">TAILQ_FOREACH</b>() starts
  at the first element and proceeds towards the last.
  <b class="Fn">TAILQ_FOREACH_REVERSE</b>() starts at the last element and
  proceeds towards the first.
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">TAILQ_FOREACH(np, &amp;head, FIELDNAME) 
TAILQ_FOREACH_REVERSE(np, &amp;head, HEADNAME, FIELDNAME)
</pre>
</div>
<div class="Pp"></div>
The macros <b class="Fn">TAILQ_FOREACH_SAFE</b>() and
  <b class="Fn">TAILQ_FOREACH_REVERSE_SAFE</b>() traverse the list referenced by
  head in a forward or reverse direction respectively, assigning each element in
  turn to var. However, unlike their unsafe counterparts, they permit both the
  removal of var as well as freeing it from within the loop safely without
  interfering with the traversal.
<div class="Pp"></div>
The <b class="Fn">TAILQ_FIRST</b>(), <b class="Fn">TAILQ_NEXT</b>(),
  <b class="Fn">TAILQ_LAST</b>() and <b class="Fn">TAILQ_PREV</b>() macros can
  be used to manually traverse a tail queue or an arbitrary part of one.
<div class="Pp"></div>
The <b class="Fn">TAILQ_EMPTY</b>() macro should be used to check whether a tail
  queue is empty.
<h1 class="Sh" id="TAIL_QUEUE_EXAMPLE">TAIL QUEUE EXAMPLE</h1>
<div class="Bd" style="margin-left: 0.00ex;">
<pre class="Li">TAILQ_HEAD(tailhead, entry) head; 
struct entry { 
	... 
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */ 
	... 
} *n1, *n2, *np; 
 
TAILQ_INIT(&amp;head);			/* Initialize queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
TAILQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
TAILQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
TAILQ_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
TAILQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Manual forward traversal. */ 
for (np = n2; np != NULL; np = TAILQ_NEXT(np, entries)) 
	np-&gt; ... 
					/* Delete. */ 
while ((np = TAILQ_FIRST(&amp;head))) { 
	TAILQ_REMOVE(&amp;head, np, entries); 
	free(np); 
} 

</pre>
</div>
<h1 class="Sh" id="SEE_ALSO">SEE ALSO</h1>
<a class="Xr" href="http://man.openbsd.org/tree.3">tree(3)</a>
<h1 class="Sh" id="NOTES">NOTES</h1>
It is an error to assume the next and previous fields are preserved after an
  element has been removed from a list or queue. Using any macro (except the
  various forms of insertion) on an element removed from a list or queue is
  incorrect. An example of erroneous usage is removing the same element twice.
<div class="Pp"></div>
The <b class="Fn">SLIST_END</b>(), <b class="Fn">LIST_END</b>(),
  <b class="Fn">SIMPLEQ_END</b>() and <b class="Fn">TAILQ_END</b>() macros are
  deprecated; they provided symmetry with the historical
  <b class="Fn">CIRCLEQ_END</b>() and just expand to
  <code class="Dv">NULL</code>.
<div class="Pp"></div>
Trying to free a list in the following way is a common error:
<div class="Pp"></div>
<div class="Bd" style="margin-left: 5.00ex;">
<pre class="Li">LIST_FOREACH(var, head, entry) 
	free(var); 
free(head);
</pre>
</div>
<div class="Pp"></div>
Since <i class="Va">var</i> is free'd, the FOREACH macros refer to a pointer
  that may have been reallocated already. A similar situation occurs when the
  current element is deleted from the list. In cases like these the data
  structure's FOREACH_SAFE macros should be used instead.
<h1 class="Sh" id="HISTORY">HISTORY</h1>
The <b class="Nm">queue</b> functions first appeared in
  <span class="Ux">4.4BSD</span>. The historical circle queue macros were
  deprecated in <span class="Ux">OpenBSD 5.5</span>.</div>
<table class="foot">
  <tbody>
    <tr>
      <td class="foot-date">January 12, 2017</td>
      <td class="foot-os">OpenBSD-current</td>
    </tr>
  </tbody>
</table>


</body></html>